import{_ as l,a as t}from"./Docker_Wasm-s6Xy7vL_.js";import{_ as r,r as o,o as d,c as m,f as e,g as s,i as a,e as i}from"./app-C9ZkQdtL.js";const c={},b=e("h2",{id:"前言",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#前言"},[e("span",null,"前言")])],-1),u={href:"https://github.com/kata-containers/kata-containers",target:"_blank",rel:"noopener noreferrer"},h={href:"https://github.com/google/gvisor",target:"_blank",rel:"noopener noreferrer"},p=i(`<p>这篇文章会介绍什么是 WebAssembly, 为什么它有成为下一代运行时实现的潜力, 并演示 WebAssembly 容器与常规的 Linux 容器的差异。</p><div class="hint-container tip"><p class="hint-container-title">延伸阅读: 什么是容器？</p><p><strong>容器镜像</strong>是一个轻量级的、独立的、可执行的<strong>软件包</strong>, 只要<strong>应用程序</strong>打包成容器镜像交付, 无论在何种基础架构(Linux 或 Windows; ARM 或 X86), 它们都将始终以相同的方式运行。</p><p><strong>容器</strong>提供一种可以快速且可靠地将<strong>应用程序</strong>从一个计算环境运行到另一个计算环境的技术, 容器是软件即服务(Software as a service, SaaS)。</p></div><h2 id="什么是-webassembly-aka-wasm" tabindex="-1"><a class="header-anchor" href="#什么是-webassembly-aka-wasm"><span>什么是 Webassembly (aka Wasm)</span></a></h2><p>WebAssembly 是一种安全的、可移植的、低级别的(类似于汇编)的编程语言(或者说是二进制指令格式, 类似于汇编), 需要在基于堆栈的虚拟机中执行。 Wasm 被设计为编程语言的可移植编译目标, 主要目标是在 Web 上实现高性能的应用。</p><h2 id="hello-wasm" tabindex="-1"><a class="header-anchor" href="#hello-wasm"><span>Hello Wasm</span></a></h2><p>我们通过简单的 Hello World Demo 快速认识什么是 Wasm 程序。</p><h3 id="源语言-rust" tabindex="-1"><a class="header-anchor" href="#源语言-rust"><span>源语言 Rust</span></a></h3><p>Wasm 是编程语言的可移植编译目标, 因此需要从另一种语言编译生成, 常见的源语言是 Rust, 以下是一个最简单的基于 Rust 的 Hello World 样例代码:</p><div class="language-rust line-numbers-mode" data-ext="rs" data-title="rs"><pre class="language-rust"><code>// file: hello.rs
fn main() {
  println!(&quot;Hello Wasm&quot;);
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>由于 Rust 的规则, 还需要编写 Cargo.toml 才能编译代码。</p><div class="language-toml line-numbers-mode" data-ext="toml" data-title="toml"><pre class="language-toml"><code>## file: Cargo.toml
[package]
name = &quot;hello&quot;
version = &quot;0.0.1&quot;

[[bin]]
name = &quot;hello&quot;
path = &quot;hello.rs&quot;

[dependencies]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试运行 hello.rs</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>❯ cargo run
   Compiling hello v0.0.1
    Finished dev [unoptimized + debuginfo] target(s) in 0.26s
     Running \`target/debug/hello\`
Hello Wasm
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="编译-wasm" tabindex="-1"><a class="header-anchor" href="#编译-wasm"><span>编译 Wasm</span></a></h3><p>默认情况下, Rust 会被编译成可执行文件, 我们需要指定额外的编译参数才能编译得到 Wasm</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>## 安装编译依赖
❯ rustup target add wasm32-wasi
info: downloading component &#39;rust-std&#39; for &#39;wasm32-wasi&#39;
info: installing component &#39;rust-std&#39; for &#39;wasm32-wasi&#39;
## 编译成 Wasm
❯ rustc hello.rs --target wasm32-wasi
## 编译生成 hello.wasm
❯ ls -lah hello.wasm
-rwxr-xr-x  1 shabbywu  staff   2.1M  1  8 16:04 hello.wasm
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="执行" tabindex="-1"><a class="header-anchor" href="#执行"><span>执行</span></a></h3><p>WebAssembly 是一种用于基于堆栈的虚拟机的二进制指令格式, 需要使用 WebAssembly 虚拟机才能执行 Wasm。常见的主要浏览器引擎(如 Chrome, Edge, Firefox 和 Safari)均支持执行 Wasm, 但想要在终端执行则需要先安装 Wasm 运行时, 以下是目前流行的 Wasm 运行时实现:</p>`,18),v={href:"https://wasmtime.dev/",target:"_blank",rel:"noopener noreferrer"},g={href:"https://bytecodealliance.org/",target:"_blank",rel:"noopener noreferrer"},y={href:"https://github.com/bytecodealliance/wasm-micro-runtime",target:"_blank",rel:"noopener noreferrer"},w={href:"https://bytecodealliance.org/",target:"_blank",rel:"noopener noreferrer"},W={href:"https://wasmer.io/",target:"_blank",rel:"noopener noreferrer"},_={href:"https://github.com/wasm3/wasm3",target:"_blank",rel:"noopener noreferrer"},f=e("strong",null,"解释器",-1),k={href:"https://wasmedge.org/",target:"_blank",rel:"noopener noreferrer"},A=i(`<p>我们选用 Star 数最多的 Wasmer 演示执行 Wasm:</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>## 安装 Wasmer
❯ curl https://get.wasmer.io -sSfL | sh
## 执行 hello.wasm
❯ wasmer run hello.wasm
Hello Wasm
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="为什么说-webassembly-具有成为下一代运行时实现的潜力" tabindex="-1"><a class="header-anchor" href="#为什么说-webassembly-具有成为下一代运行时实现的潜力"><span>为什么说 WebAssembly 具有成为下一代运行时实现的潜力？</span></a></h2><p>Wasm 的特性让它充满无限可能:</p>`,4),x=i("<li><strong>标准</strong> —— Wasm 被设计成无版本、特性可测试、向后兼容的, 主流浏览器均已实现初版 Wasm 规范。</li><li><strong>快速</strong> —— 它可以通过大多数运行时的 JIT/AOT 能力提供类似原生的速度。 与启动 VM 或启动容器不同的是, 它没有冷启动。</li><li><strong>安全</strong> —— 默认情况下, Wasm 运行时是沙箱化的, 允许安全访问内存。基于能力的模型确保 Wasm 应用程序只能访问得到明确允许的内容。软件供应链更加安全。</li><li><strong>可移植</strong> —— Wasm 的二进制格式是被设计成可在不同操作系统(目前支持 Linux、Windows、macOS、Android、甚至是嵌入式设备)与指令集（目前支持 x86、ARM、RISC-V等）上高效执行的。</li><li><strong>高性能</strong> —— Wasm 只需极小的内存占用和超低的 CPU 门槛就能运行。</li>",5),S=e("strong",null,"支持多语言",-1),T={href:"https://github.com/appcypher/awesome-wasm-langs",target:"_blank",rel:"noopener noreferrer"},q=e("h3",{id:"webassembly-正从浏览器走向服务端",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#webassembly-正从浏览器走向服务端"},[e("span",null,"WebAssembly 正从浏览器走向服务端")])],-1),C={href:"https://github.com/WebAssembly/WASI/blob/main/phases/snapshot/docs.md",target:"_blank",rel:"noopener noreferrer"},P={href:"https://github.com/bytecodealliance/wasmtime/blob/main/crates/wasi-common/src/snapshots/preview_1.rs#L596",target:"_blank",rel:"noopener noreferrer"},D={href:"https://wasmtime.dev/",target:"_blank",rel:"noopener noreferrer"},E=e("p",null,[s("作为开发者并不需要关心 Wasm 虚拟机的具体实现, 只需要将应用程序编译为 Wasm 二进制指令即可在任意服务器上执行。 "),e("img",{src:l,alt:"Wasm执行在服务端的原理",loading:"lazy"})],-1),I=e("h3",{id:"webassembly-对软件交付的影响",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#webassembly-对软件交付的影响"},[e("span",null,"WebAssembly 对软件交付的影响")])],-1),O={href:"https://github.com/opencontainers/runtime-spec/blob/main/principles.md",target:"_blank",rel:"noopener noreferrer"},H=i('<ul><li>Standard operations(标准操作): Wasm 定义了 main 函数作为主入口, Wasm 虚拟机执行 main 函数即可启动 Wasm 程序。</li><li>Content-agnostic(与内容无关): Wasm 编译后以二进制文件交付, 天然与内容无关。</li><li>Infrastructure-agnostic(与基础设施无关): Wasm 依赖基于堆栈的虚拟机, 而虚拟机实现不依赖基础设施。</li><li>Industrial-grade delivery(工业级交付): Wasm 一次编译, 到处执行。Wasm 无需关心软件交付的问题。</li><li>❌ Designed for automation(为自动化而设计): Wasm 并不关心自动化部署的事宜, 但这不影响 Wasm 容器化，只是目前仍然缺乏标准流程和工具链(类似于 Dockerfile 和 Docker Cli)。</li></ul><p>WebAssembly 的特性让它天生支持容器化，<em>如果应用程序都编译成 Wasm 交付</em>, 那意味着我们只需要完成一系列的封装操作，即可将 Wasm 程序自动化部署至所有服务器。为此, Solomon Hykes(Docker创始人)甚至提出 WASM+WASI 将是服务器软件基础设施的下一个发展方向。</p><div class="hint-container warning"><p class="hint-container-title">[Solomon Hykes(Docker创始人)的推文]((https://twitter.com/solomonstre/status/1111004913222324225))</p><p>&quot;If WASM+WASI existed in 2008, we wouldn&#39;t have needed to created Docker. That&#39;s how important it is. Webassembly on the server is the future of computing. A standardized system interface was the missing link. Let&#39;s hope WASI is up to the task!&quot; -- Solomon Hykes, creator of Docker</p></div><p>确实, 如果操作系统集成了 Wasm 虚拟机(就像浏览器一样), 同时<em>如果应用程序都编译成 Wasm</em>, 那么我们根本不需要 &quot;Linux 容器&quot;, 不需要虚拟一层完整的 Linux 操作系统, 只需要 Wasm 虚拟机, 即可完成 Wasm 程序的&quot;容器化部署&quot;。</p><h2 id="容器化-webassembly" tabindex="-1"><a class="header-anchor" href="#容器化-webassembly"><span>容器化 WebAssembly</span></a></h2><p>Docker 在 2022 年 10 月 24 日宣布将在 Docker Desktop 4.15 以 Beta 特性支持运行 Wasm 容器！正如前文所言, Wasm 是一个更快、更轻量的 Linux/Windows 容器的替代品。这一节将演示 Wasm 容器与常规的 Linux 容器的差异，包括构建 Wasm 镜像、运行 Wasm 容器和原生执行的对比。 <img src="'+t+'" alt="Docker+Wasm" loading="lazy"></p><h3 id="构建并运行-wasm-镜像" tabindex="-1"><a class="header-anchor" href="#构建并运行-wasm-镜像"><span>构建并运行 Wasm 镜像</span></a></h3>',7),R={href:"https://github.com/python/cpython",target:"_blank",rel:"noopener noreferrer"},N=e("p",null,"与 C 和 Rust 等编译型语言不同, 对于 Python、Ruby 等解释型语言, 我们需要将它们的解释器编译成 Wasm。一旦将解释器编译为 Wasm, 任何 Wasm 虚拟机都能够运行这些解释型语言。",-1),L={href:"https://github.com/singlestore-labs/python-wasi.git",target:"_blank",rel:"noopener noreferrer"},M=i(`<h4 id="_0-整理项目结构" tabindex="-1"><a class="header-anchor" href="#_0-整理项目结构"><span>0. 整理项目结构</span></a></h4><p>为了方便描述, 我们假设项目结构符合以下目录树, 具体内容见上文。</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>.
├── build.sh
└── src
    ├── main.py
    |── [cpython](https://github.com/python/cpython/archive/refs/tags/v3.11.1.tar.gz)
    └── [python-wasi](https://github.com/singlestore-labs/python-wasi)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中, main.py 内容如下:</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code>import os
## 打印环境变量, 测试安全性
for k, v in os.environ.items():
  print(f&quot;{k}={v}&quot;)

print(&quot;------&quot;)
print(&quot;Hello World&quot;)
print(&quot;------&quot;)
print(os.listdir())
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_1-编写-buildah-构建脚本" tabindex="-1"><a class="header-anchor" href="#_1-编写-buildah-构建脚本"><span>1. 编写 buildah 构建脚本</span></a></h4><p>目前 Docker Engine 并未支持构建 Wasm 镜像, 因此需要使用 buildah 进行镜像构建, 由于需要将 CPython 编译成 wasm, 因此需要使用多阶段构建。</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>## build.sh
### python-wasi-builder
buildah from --format=docker --name python-wasi-builder docker.io/435495971/python-wasi-builder
buildah copy python-wasi-builder src/python-wasi .
buildah copy python-wasi-builder src/cpython cpython
buildah run -e WASMTIME_HOME=/root/.wasmtime -e WASI_SDK_PATH=/opt/wasi-sdk -e WASMTIME_BACKTRACE_DETAILS=1 -e PATH=/root/.wasmtime/bin:/opt/wasi-sdk/bin:/root/.wasmer/bin:/opt/wabt/build:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin python-wasi-builder /bin/bash run.sh

### wasm image
buildah from --name wasm-cpython scratch
buildah copy --from python-wasi-builder wasm-cpython wasi-python3.11.wasm /python3.wasm
buildah copy wasm-cpython src/main.py main.py 
buildah config --annotation &quot;module.wasm.image/variant=compat&quot; --entrypoint &#39;[&quot;python3.wasm&quot;, &quot;main.py&quot;]&#39; --os wasi --arch wasm32 wasm-cpython
buildah commit wasm-cpython docker.io/435495971/wasm-cpython
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了方便阅读, 上述 build.sh 与下列的 Dockerfile 等价</p><div class="language-docker line-numbers-mode" data-ext="docker" data-title="docker"><pre class="language-docker"><code>FROM docker.io/435495971/python-wasi-builder as build
COPY src/python-wasi .
COPY src/cpython cpython
SHELL [&quot;/bin/bash&quot;, &quot;-c&quot;] 
ENV WASMTIME_HOME=/root/.wasmtime
ENV WASI_SDK_PATH=/opt/wasi-sdk
ENV WASMTIME_BACKTRACE_DETAILS=1
ENV PATH=/root/.wasmtime/bin:/opt/wasi-sdk/bin:/root/.wasmer/bin:/opt/wabt/build:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
RUN ./run.sh

FROM scratch
COPY --from=build wasi-python3.11.wasm /python3.wasm
COPY src/main.py main.py
ENTRYPOINT [ &quot;python3.wasm&quot;, &quot;main.py&quot;]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_2-构建并上传镜像" tabindex="-1"><a class="header-anchor" href="#_2-构建并上传镜像"><span>2. 构建并上传镜像</span></a></h4><p>构建镜像时需要指定平台架构为 <code>wasi/wasm32</code></p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>## 构建镜像
❯ chmod +x build.sh
❯ ./build.sh
❯ buildah push docker.io/435495971/wasm-cpython
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_3-运行镜像" tabindex="-1"><a class="header-anchor" href="#_3-运行镜像"><span>3. 运行镜像</span></a></h4>`,14),V=e("code",null,"wasi/wasm32",-1),Y=e("code",null,"wasi/wasm32",-1),B=e("code",null,"io.containerd.wasmedge.v1",-1),F={href:"https://github.com/containerd/runwasi",target:"_blank",rel:"noopener noreferrer"},z=i(`<div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>❯ ctr run --rm \\
  --runtime=io.containerd.wasmtime.v1 \\
  docker.io/435495971/wasm-cpython:latest \\
  testwasm

PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
------
Hello World
------
[&#39;main.py&#39;, &#39;python3.wasm&#39;]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="原生-vs-wasm" tabindex="-1"><a class="header-anchor" href="#原生-vs-wasm"><span>原生 vs Wasm</span></a></h3><p>现在我们将<strong>原生 Linux Container</strong>执行与 Wasm 执行进行比较, 对照组使用以下 Dockerfile 构建。</p><div class="language-docker line-numbers-mode" data-ext="docker" data-title="docker"><pre class="language-docker"><code>FROM python:3.11.1
COPY main.py main.py
ENTRYPOINT [&quot;python&quot;, &quot;main.py&quot;]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以下是构建镜像执行的输出结果:</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>## docker run -it --rm raw-example 
PATH=/usr/local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
HOSTNAME=ab16d4f1dbe1
TERM=xterm
LANG=C.UTF-8
GPG_KEY=A035C8C19219BA821ECEA86B64E628F8D684696D
PYTHON_VERSION=3.11.1
PYTHON_PIP_VERSION=22.3.1
PYTHON_SETUPTOOLS_VERSION=65.5.1
PYTHON_GET_PIP_URL=https://github.com/pypa/get-pip/raw/66030fa03382b4914d4c4d0896961a0bdeeeb274/public/get-pip.py
PYTHON_GET_PIP_SHA256=1e501cf004eac1b7eb1f97266d28f995ae835d30250bec7f8850562703067dc6
HOME=/root
------
Hello World
------
[&#39;mnt&#39;, &#39;home&#39;, &#39;var&#39;, &#39;run&#39;, &#39;boot&#39;, &#39;srv&#39;, &#39;tmp&#39;, &#39;sbin&#39;, &#39;media&#39;, &#39;dev&#39;, &#39;bin&#39;, &#39;lib&#39;, &#39;root&#39;, &#39;opt&#39;, &#39;etc&#39;, &#39;sys&#39;, &#39;usr&#39;, &#39;lib64&#39;, &#39;proc&#39;, &#39;.dockerenv&#39;, &#39;main.py&#39;]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从对照实验可以看出, Wasm 容器输出的环境变量更少, 这是 Wasm 安全特性导致的。除非明确声明，否则 Wasm 程序无法获取到任何额外的环境变量。同时, 由于 Wasm 编译后不依赖外部链接, 容器内容更简洁。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>本文首先介绍了什么是 WebAssembly 以及 WebAssembly 为何具备成为下一代运行时实现的潜力。最后展示了如何构建 WebAssembly 容器, 并简单对比了 WebAssembly 容器和 Linux 容器的运行差异。</p>`,9);function K(U,Z){const n=o("ExternalLinkIcon");return d(),m("div",null,[b,e("p",null,[s("2013年3月20日, DotCloud 发布了 Docker 的首个版本, 从此开启了容器化时代的序幕。现在是容器化时代, 不管是开发、测试还是运维, 很少有人会不知道或不会用 Docker。自 Docker 发布至今的 10年内, 开源和社区共建让容器化技术如日中天。尽管容器化产品迭代迅速, 但是容器技术的核心却一直围绕着 Linux, 每当我们提及容器时, 实际上我们指代的往往是基于 Linux Kernel 的运行时实现。 时至今日, 除了 Linux 容器以外还有很多容器运行时实现, 例如 "),e("a",u,[s("Kata Containers"),a(n)]),s(" 和 "),e("a",h,[s("gVisor"),a(n)]),s(", 那究竟谁会是下一代运行时实现呢？-- 很可能是 Webassembly。")]),p,e("ul",null,[e("li",null,[e("a",v,[s("Wasmtime"),a(n)]),s(", 是由"),e("a",g,[s("字节码联盟(Bytecode Alliance)"),a(n)]),s("开发的快速, 安全的 WebAssembly 运行时。")]),e("li",null,[e("a",y,[s("WAMR"),a(n)]),s(", 是由"),e("a",w,[s("字节码联盟(Bytecode Alliance)"),a(n)]),s("开发的 WebAssembly 轻量级运行时, 适用于嵌入式、物联网、边缘计算、智能设备等场景。")]),e("li",null,[e("a",W,[s("Wasmer"),a(n)]),s(" 提供基于 WebAssembly 的超轻量级容器,其可以在任何地方运行：从桌面到云、以及 IoT 设备, 并且也能嵌入到 任何编程语言中。")]),e("li",null,[e("a",_,[s("Wasm3"),a(n)]),s(" 是最快 WebAssembly "),f,s(", 也是最通用的 Wasm 运行时。")]),e("li",null,[e("a",k,[s("WasmEdge"),a(n)]),s(" 是一种轻量级、高性能且可扩展的 WebAssembly 运行时, 适用于云原生、边缘和去中心化应用程序。 它为无服务器应用程序、嵌入式功能、微服务、智能合约和物联网设备提供支持。")])]),A,e("ul",null,[x,e("li",null,[s("️"),S,s(" —— "),e("a",T,[s("多种编程语言"),a(n)]),s("可以编译成 Wasm。")])]),q,e("p",null,[s("WebAssembly 起源于浏览器, 最初主要用于补齐 JavaScript 在执行性能方面的短板, 但 Wasm 并非为了取代 JavaScript, 而是希望提供一种在浏览器(沙盒环境)执行大型应用程序的能力。 Wasm 依赖虚拟机执行, 而浏览器引擎能运行 Wasm 程序是因为浏览器引起集成了 Wasm 虚拟机。如果将 Wasm 虚拟机剥离出来单独运行, 那我们就可以在浏览器之外的地方执行 Wasm 程序。与浏览器执行环境不同, 服务端程序需要与外部环境(如文件系统、网络等)交互, 由于 Wasm 设计上是在安全沙箱执行的语言, 与外部环境交互将引入潜在的安全风险，因此 Wasm 提出了 "),e("a",C,[s("WASI(WebAssembly System Interface)"),a(n)]),s(" 描述了 Wasm 程序支持的操作接口。")]),e("blockquote",null,[e("p",null,[s("WASI 由 Wasm 运行时实现, 例如 "),e("a",P,[s("fd_readdir"),a(n)]),s(" 是 "),e("a",D,[s("Wasmtime"),a(n)]),s(" 的读取目录接口的实现。")])]),E,I,e("p",null,[s("在容器化时代, 容器已成为软件交付的事实标准，基本上所有软件均提供了「容器」部署的方案。 为了统一容器的生命周期管理和交付介质，Open Container Initiative(OCI)提出了"),e("a",O,[s("5点标准容器需要符合的原则"),a(n)]),s(", 而 WebAssembly 基本符合这些原则:")]),H,e("p",null,[s("我们知道, 对于编译型语言最终生成的是 .wasm 文件, 编译镜像无任何技术含量。为了提高挑战性, 我们使用解释型语言 "),e("a",R,[s("CPython"),a(n)]),s(" 完成这一节的演示。")]),N,e("p",null,[s("理论如此, 但由于 WASI 并未提供完整的 POISX 兼容, 在编译 CPython 时需要修改部分源码, 开源项目 "),e("a",L,[s("python-wasi"),a(n)]),s(" 已完成了这个实验, 借助该项目即可将 CPython 编译成 Wasm。")]),M,e("p",null,[s("运行 "),V,s(" 需要指定平台架构为 "),Y,s(" 和运行时为 "),B,s(", 由于 WASI 协议不稳定, 目前只有 wasmtime 可以运行 wasm-cpython, 因此只能使用 "),e("a",F,[s("runwasi"),a(n)]),s(" 运行 Wasm 容器。")]),z])}const j=r(c,[["render",K],["__file","wasm-or-container.html.vue"]]),X=JSON.parse('{"path":"/posts/2023/01/08/wasm-or-container.html","title":"Webassembly - 会是下一代的容器运行时吗?","lang":"zh-CN","frontmatter":{"draft":false,"permalinkPattern":"/posts/:year/:month/:day/:slug.html","type":"post","filePathRelative":"_posts/container/2023-01-08-WASM-or-Container.md","date":"2023-01-08T00:00:00.000Z","title":"Webassembly - 会是下一代的容器运行时吗?","sidebarDepth":2,"category":"容器技术","tags":["Webassembly"],"description":"前言 2013年3月20日, DotCloud 发布了 Docker 的首个版本, 从此开启了容器化时代的序幕。现在是容器化时代, 不管是开发、测试还是运维, 很少有人会不知道或不会用 Docker。自 Docker 发布至今的 10年内, 开源和社区共建让容器化技术如日中天。尽管容器化产品迭代迅速, 但是容器技术的核心却一直围绕着 Linux, 每当...","head":[["link",{"rel":"alternate","hreflang":"en-us","href":"https://blog.shabbywu.cn/en/posts/2023/01/08/wasm-or-container.html"}],["meta",{"property":"og:url","content":"https://blog.shabbywu.cn/posts/2023/01/08/wasm-or-container.html"}],["meta",{"property":"og:site_name","content":"个人技术文章分享"}],["meta",{"property":"og:title","content":"Webassembly - 会是下一代的容器运行时吗?"}],["meta",{"property":"og:description","content":"前言 2013年3月20日, DotCloud 发布了 Docker 的首个版本, 从此开启了容器化时代的序幕。现在是容器化时代, 不管是开发、测试还是运维, 很少有人会不知道或不会用 Docker。自 Docker 发布至今的 10年内, 开源和社区共建让容器化技术如日中天。尽管容器化产品迭代迅速, 但是容器技术的核心却一直围绕着 Linux, 每当..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://blog.shabbywu.cn/img/Wasm-work-on-servers.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:locale:alternate","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-03-10T12:21:46.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"Webassembly - 会是下一代的容器运行时吗?"}],["meta",{"property":"article:author","content":"shabbywu"}],["meta",{"property":"article:tag","content":"Webassembly"}],["meta",{"property":"article:published_time","content":"2023-01-08T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-03-10T12:21:46.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Webassembly - 会是下一代的容器运行时吗?\\",\\"image\\":[\\"https://blog.shabbywu.cn/img/Wasm-work-on-servers.png\\",\\"https://blog.shabbywu.cn/img/Docker+Wasm.png\\"],\\"datePublished\\":\\"2023-01-08T00:00:00.000Z\\",\\"dateModified\\":\\"2024-03-10T12:21:46.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"shabbywu\\",\\"url\\":\\"https://github.com/shabbywu\\"}]}"],["link",{"rel":"alternate","type":"application/atom+xml","href":"https://blog.shabbywu.cn/atom.xml","title":"个人技术文章分享 Atom Feed"}],["link",{"rel":"alternate","type":"application/json","href":"https://blog.shabbywu.cn/feed.json","title":"个人技术文章分享 JSON Feed"}],["link",{"rel":"alternate","type":"application/rss+xml","href":"https://blog.shabbywu.cn/rss.xml","title":"个人技术文章分享 RSS Feed"}]]},"headers":[{"level":2,"title":"前言","slug":"前言","link":"#前言","children":[]},{"level":2,"title":"什么是 Webassembly (aka Wasm)","slug":"什么是-webassembly-aka-wasm","link":"#什么是-webassembly-aka-wasm","children":[]},{"level":2,"title":"Hello Wasm","slug":"hello-wasm","link":"#hello-wasm","children":[{"level":3,"title":"源语言 Rust","slug":"源语言-rust","link":"#源语言-rust","children":[]},{"level":3,"title":"编译 Wasm","slug":"编译-wasm","link":"#编译-wasm","children":[]},{"level":3,"title":"执行","slug":"执行","link":"#执行","children":[]}]},{"level":2,"title":"为什么说 WebAssembly 具有成为下一代运行时实现的潜力？","slug":"为什么说-webassembly-具有成为下一代运行时实现的潜力","link":"#为什么说-webassembly-具有成为下一代运行时实现的潜力","children":[{"level":3,"title":"WebAssembly 正从浏览器走向服务端","slug":"webassembly-正从浏览器走向服务端","link":"#webassembly-正从浏览器走向服务端","children":[]},{"level":3,"title":"WebAssembly 对软件交付的影响","slug":"webassembly-对软件交付的影响","link":"#webassembly-对软件交付的影响","children":[]}]},{"level":2,"title":"容器化 WebAssembly","slug":"容器化-webassembly","link":"#容器化-webassembly","children":[{"level":3,"title":"构建并运行 Wasm 镜像","slug":"构建并运行-wasm-镜像","link":"#构建并运行-wasm-镜像","children":[]},{"level":3,"title":"原生 vs Wasm","slug":"原生-vs-wasm","link":"#原生-vs-wasm","children":[]}]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"readingTime":{"minutes":10.55,"words":3165},"filePathRelative":"_posts/container/2023-01-08-wasm-or-container.md","localizedDate":"2023年1月8日","autoDesc":true,"git":{"createdTime":1708758647000,"updatedTime":1710073306000,"contributors":[{"name":"shabbywu","email":"shabbywu@tencent.com","commits":3}]}}');export{j as comp,X as data};
