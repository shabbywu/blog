---
date: 2020-11-22
title: Python异步编程-探讨协程实现异步的细节
sidebarDepth: 3
category: python
tags:
-   python
-   coroutine
draft: false
---
# 序言
在上回 [Python异步初探-协程的定义](/posts/2019/10/14/python异步初探-协程的定义.html) 里，我们探讨了协程的本质，明确了**协程本身并未解决异步编程的问题**，而是提供了一套**由用户主动分配CPU时钟**的可行方案。通过恰当的调度   
接下来，本文将会从任务调度入手，探讨 Python 借助协程实现异步的细节。

# 多线程的任务调度
**线程** 是操作系统进行CPU分配和调度的单位，如果我们需要进行异步编程，首先想到的必然是多线程模型，只需要几行代码，就能启动线程执行异步任务。
```python
import threading
import time


def task(task_id):
    start_clock = time.process_time()
    print(f"task<{task_id}> start")
    # 模拟阻塞
    time.sleep(10)
    print(f"task<{task_id}> end, cost cpu time: {time.process_time() - start_clock}")

for i in range(5):
    threading.Thread(target=task, args=(i, )).start()
```

上面的代码是 Python 多线程异步编程的样例，接下来我们来分析多线程任务执行的顺序。
## 操作系统调度
当启动一个线程时，线程并非立即执行，而是在等待操作系统的资源调度。当线程被分配到CPU时钟时，线程才真正开始执行。

@startuml
scale 10 as 150 pixels

robust "CPU状态" as CPU
concise "CPU时钟分配" as Slice

CPU is 空闲
Slice is 时间片

@CPU
0 is 线程1: 操作系统分配任务至 CPU
15 is 线程2: 切换至线程2
25 is 线程1: 线程2执行完毕
35 is 空闲: 线程1执行完毕

@Slice
0 is 时间片
15 is 时间片
25 is 时间片
35 is 时间片

Slice@15 -> CPU@15: 上下文切换
Slice@25 -> CPU@25: 上下文切换
Slice@35 -> CPU@35: 上下文切换
@enduml

> CPU能执行那个线程，是通过操作系统设置的调度策略而决定的，如果感兴趣可以阅读操作系统相关的书籍，这里就不展开了。

继续讨论回我们上面给的样例，如果我们重复执行几次这个样例, 就会发现, 多线程任务的调度策略和启动顺序是无关的，在重复执行多次还能发现，每次任务调度的顺序也是无关的。
```bash
# 第一次执行的输出结果
task<0> start
task<1> start
task<2> start
task<3> start
task<4> start
## 这里等待了 10 秒
task<0> end, cost cpu time: 0.000682000000000002
task<4> end, cost cpu time: 0.0003599999999999992
task<3> end, cost cpu time: 0.0005119999999999986
task<2> end, cost cpu time: 0.0005790000000000031
task<1> end, cost cpu time: 0.0006910000000000041

# 第二次执行的输出结果
task<0> start
task<1> start
task<2> start
task<3> start
task<4> start
## 这里等待了 10 秒
task<0> end, cost cpu time: 0.0005179999999999976
task<2> end, cost cpu time: 0.0005100000000000035
task<3> end, cost cpu time: 0.00044700000000000295
task<1> end, cost cpu time: 0.0006960000000000022
task<4> end, cost cpu time: 0.0003809999999999994
```
由于多线程的任务调度是由操作系统底层的调度算法决定的，导致 **用户无法决定线程被分配的CPU时间片大小和各线程的执行顺序**。   

## 任务队列-控制线程任务执行顺序的方案
针对控制线程执行顺序的需求，事实上就是要在用户态模拟操作系统针对线程的调度算法，最直观的实现方案就是用**优先队列**将异步任务缓冲起来，再由用户程序**按任务优先级排序**，调度器只需依序执行即可。这种类型的异步任务执行模型如下:

@startuml
frame Thread {
    cloud task
}

queue TaskPriorityQueue {
    cloud taskA
    cloud taskN
    left to right direction
    taskA ~~ taskN
}

cloud newTask
task <-- taskA 
taskN <-- newTask
@enduml


虽然这个模型在设计上满足需求的，但是在编程实现时又引入了新问题: **何时创建线程执行异步任务？**   
如果是在创建异步任务时，马上创建新的线程执行任务，那么这个模型和原来的原地创建线程并未任何本质差异，因此不可能同时创建任务和创建线程。   
通过分析这个模型可以发现，这是典型的生产者消费者模式，只要生产者(推送任务到队列)和消费者(创建新线程执行任务)分别在两个不同的线程运行，那就可以“避免”同时创建任务和创建线程的问题了，调整后的模型如下：

@startuml
frame Producer {
    cloud newTask
}

frame Consumer {
    cloud task
}

queue TaskQueue {
    cloud taskA
    cloud taskN
    left to right direction
    taskA ~~ taskN
}

task <-- taskA 
taskN <-- newTask
task --> newThread
@enduml

对应的实现代码也很简单: 
```python
def consumer(queue):
    while: True
        task, args, kwargs = queue.get()    
        threading.Thread(target=task, args=args, kwargs=kwargs).start()
        time.sleep(some_preset_threshold)
```
通过将原来的异步任务执行模型改造成上图所示的生产者消费者模式后，看似解决了创建线程的问题，但是再仔细分析新的模型，可以发现消费者的消费速率会始终高于生产者创建异步任务的速率（因为消费者的任务只是创建新的线程），这导致在新的模型中，仍然有很大概率出现同时创建任务和创建线程的问题。   

方案设计仿佛又回到了原点，通过引入队列解决了任务执行优先级的问题，但是并未解决创建线程执行任务的时机。
## 明确消费者的责任
让我们重新回顾最初的异步任务执行模型，我们使用优先队列实现任务缓冲池，再创建新的线程执行其中的任务。其实我们只是需要消费者从队列中取出任务，并将其执行，也就是消费者就是执行任务的线程。

@startuml
frame Thread/Consumer {
    cloud task
    cloud task...
    task ~~ task...
}

queue TaskQueue {
    cloud taskA
    cloud taskN
    left to right direction
    taskA ~~ taskN
}

cloud newTask
task... <-- taskA 
taskN <-- newTask
@enduml

对应的实现代码也很简单: 
::: tip
事实上, 这也是一个简单的线程池化的实现。
:::
```python
def consumer(queue):
    while: True
        task, args, kwargs = queue.get()    
        task(*args, **kwargs)
```
至此，我们就可以通过组合 **优先队列** 和 **线程池** 来简单实现 **任务执行顺序可控的多线程调度系统**。
我们知道, 协程又被称之为用户态线程, 接下来，我们探讨如何将此与**协程**结合，实现所谓的异步编程系统。

# 协程的任务调度系统
在上回 [Python异步初探-协程的定义](/posts/2019/10/14/python异步初探-协程的定义.html) 里，我们介绍了 Python 主要通过 **yield**/**send** 两个原语实现了对虚拟机栈帧的保存和复原，属于*非对称式协程*，接下来我们将重点放在**如何实现协程的异步系统**。

## 任务调度系统设计的关键点
我们知道，协程又被称为用户态线程，只有当一个协程主动让出 CPU 的使用权，另一个协程才会被执行。
首先观察一下线程的生命周期，一个线程的生命周期可能会在5个状态中轮转， 分别是创建，就绪，运行，阻塞，终止，这几种关系的状态转移关系入下图所示:

@startuml
(创建) -> (就绪): 资源被分配
(就绪) -> (运行): 线程被调度
(运行) -> (就绪): 时间片执行完
(运行) --> (阻塞): 等待 IO 操作或竞争条件
(阻塞) -> (就绪): IO 操作完成
(运行) -> (终止): 线程执行完毕, 被销毁
@enduml

要实现协程的异步系统，其实就是解决一个问题：**如何调度协程的执行**？如果从任务的角度看待这个问题，可以将其拆解为以下几点:
- 何时让出 CPU？
- CPU 让给了谁？
- 何时继续执行？

### 何时让出 CPU？-- 控制权转移的时机
协程的最佳使用场景是IO密集型的应用，当需要等待 IO 操作执行时，协程可以主动让出 CPU 的使用权，避免浪费 CPU 资源。因此，协程应该在需要等待其他资源执行的地方主动让出 CPU，用伪代码描述如下:
```python
def co():
    result = yield one_blocking()
    handle(result)
    result = yield the_other_blocking()
    handle(result)
```

### CPU 让给了谁？-- 任务的调度器
在上回 [Python异步初探-协程的定义](/posts/2019/10/14/python异步初探-协程的定义.html#协程的官方实现介绍) 里，我们讲解了**非对称式协程**的执行顺序：非对称式协程通过 `send` 原语将控制权转移至子协程(被调用者)，再通过 `yield` 原语将控制权返回到其父协程(调用者)。
因此，协程的异步系统需要一个调度器负责接收子协程让渡出去的控制权，再从任务队列中挑选合适的协程继续执行。与此同时，这个调度器还需要保证只有当需要等待的 IO 操作执行完毕后，才继续执行上一个协程，用伪代码描述如下:
```python
def scheduler():
    while True:
        # 获取协程任务列表
        cos = list(task_queue)
        for co in cos:
            ret = co.send()
            if ret is some_blocking:
                ret.callback = co
                task_queue.put(ret)
            elif hasattr(co, "callback"):
                task_queue.put(co.callback)
            else:
                task_queue.pop(co)
```
### 何时继续执行？ -- 基于回调的事件处理机制
对于多线程而言，由于任务调度是委托至操作系统完成的，程序无需关心线程被阻塞后的执行情况。   
但是对于协程调度系统而言，如果其中一个协程被阻塞，就意味着整个系统都被阻塞，只有当阻塞操作完成后，协程系统才会继续运行下去。
阻塞对整个协程系统是毁灭性的，所有协程都应该只允许使用非阻塞 IO 操作，同时在调用 IO 操作后，需要马上让渡出 CPU 的使用权给调度器，当调度器判断 IO操作完成后，再继续执行该协程。
单个协程的调度流程可以参考以下的时序图: 

@startuml
调度器 -> 协程
activate 协程 #FFBBBB
协程 -> 调度器: IO blocking
activate 协程 #DarkSalmon
调度器 -> 调度器: 调度其他协程
...
[o-> 调度器: 通知 IO 操作完成
调度器 -> 协程: 继续执行该协程
deactivate 协程
协程 -> 调度器: 执行完毕
deactivate 协程
@enduml

对于网络IO、磁盘IO等调用，操作系统均提供了异步读写的系统调用(system call)。一般而言，异步 IO 调用会返回文件描述符（句柄），用户程序只需要调用操作系统提供的 API，就可以知道 IO 操作是否完成。
简而言之，只需要在调度器中增加判断 IO 操作是否执行完毕的操作即可，用伪代码描述如下:

```python
def scheduler():
    while True:
        # 获取协程任务列表
        cos = list(task_queue)
        for co in cos:
            ret = co.send()
            if ret is some_blocking:
                ret.callback = co
                task_queue.put(ret)
            elif ret is io_operation:
                ret.callback = co
                register_io_operation(ret)
            elif hasattr(co, "callback"):
                task_queue.put(co.callback)
            else:
                task_queue.pop(co)
        
        # 获取已完成的 IO 操作
        ops = get_completed_io_operations()
        for op in ops:
            task_queue.put(op.callback)
```

### 何时继续执行？ -- 处理与操作系统无关的阻塞
除了由于IO导致的阻塞以外, 很多时候我们只希望等待几秒钟再执行, 例如在标准库 `asyncio` 中提供了以下的语法。

```python
import time
import asyncio

async def co():
    start = time.time()
    print("It's going to sleep 1s.")
    await asyncio.sleep(1)
    end = time.time()
    print(f"{end - start}s passed.")


if __name__ == '__main__':
    # 输出: 
    # It's going to sleep 1s.
    # 1.0028209686279297s passed.
    asyncio.run(co())

```

上述例子中关键的代码是: **await asyncio.sleep(1)**，其所描述的含义是: **等待1秒, 随后继续执行**。
参考对于 **io_operation** 的处理, 这类型的阻塞可以抽象成 **timeout_operation**, 当满足继续执行的条件后, 再将相应的操作注册会任务队列之中，用伪代码描述如下:
```python
def scheduler():
    ...
    ret = co.send()
    if ret is timeout_operation:
        ret.callback = co
        register_timeout_operation(ret)
    
    ...

    ops = get_timeout_operations()
    for op in ops:
        task_queue.put(op.callback)
    ...
```
至此, 我们已经具备实现一个简易的基于协程的异步系统的基本理论知识, 但仍然有一点是我们尚未讨论的, 那就是**如何解决阻塞任务的返回值传递问题**。

### 除了调度之外, 你还需要了解的一些细节 
在 **非对称式协程** 中,  `send` 原语不仅仅是控制权转移至子协程(被调用者)，还充当了参数传递的作用。而 `yield` 原语也不仅仅是将控制权返回到其父协程(调用者)，还可以将返回值带回父协程，参考以下的代码:
```python
def coroutine():
    arg = yield 1
    print("参数: ", arg)

if __name__ == "__main__":
    # 输出:
    # 返回值:  1
    # 参数:  2
    co = coroutine()
    print("返回值: ", co.send(None))
    co.send(2)

```
将该逻辑整合至单个协程的调度流程时序图:

@startuml
调度器 -> 协程
activate 协程 #FFBBBB
协程 -> 调度器: IO blocking
activate 协程 #DarkSalmon
调度器 -> 调度器: 调度其他协程
...
[o-> 调度器: 通知 IO 操作完成
调度器 -> 协程: 继续执行该协程, **并传递IO操作的返回值**
deactivate 协程
协程 -> 调度器: 执行完毕
deactivate 协程
@enduml

我们可以发现, 对于**返回值**的处理是属于**调度器**的任务, 因此想要解决阻塞任务的返回值传递问题，只需要调度器在处理回调时，将对应的返回值一并带上即可，用伪代码描述如下:
::: tip
以下代码仅在于描述核心逻辑。
在实现异步系统返回值处理时, 常见的机制为: Promise/Future。
:::

```python
def scheduler():
    while True:
        cos = list(task_queue)
        for co, args in cos:
            ret = co.send(args)
            if ret is some_blocking:
                ret.callback = co
                task_queue.put(ret)
            elif ret is io_operation:
                ret.callback = co
                register_io_operation(ret)
            elif ret is timeout_operation:
                ret.callback = co
                register_timeout_operation(ret)
            elif hasattr(co, "callback"):
                task_queue.put(co.callback)
            else:
                task_queue.pop(co)
        
        ops = get_completed_io_operations()
        for op, result in ops:
            task_queue.put((op.callback, result))

        ops = get_timeout_operations()
        for op in ops:
            task_queue.put((op.callback, None))
```

# 总结
在这篇文章里，我们首先围绕着**多线程的任务调度**这一话题，从操作系统调度多线程的原理出发，逐步深入探讨在用户态控制多线程任务执行顺序的方案的设计和实现，总结出可以通过组合 **优先队列** 和 **线程池** 来简单实现 **任务执行顺序可控的多线程调度系统**。
在解决任务执行顺序之后, 我们从协程的角度出发, 分别从 **调出对象**、**调出时机**、**调回时机** 三个问题来分析 **协程调度** 的问题，最后总结出实现协程调度器所需的基本要素为以下几点:
- 任务队列
- 操作系统IO回调处理机制
- 延迟执行机制
- 返回值传递机制

协程异步系统依赖于操作系统异步IO的系统调用，因此在不同操作系统上需要实现可能会有所差异。同时，由于其本质上是在用户态中模拟操作系统调度线程的行为，因此对于不同的编程语言，相应的调度算法实现也会不尽相同。