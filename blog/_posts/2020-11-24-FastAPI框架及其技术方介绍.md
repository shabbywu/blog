---
date: 2020-11-24
title: FastAPI框架简介及其技术方案分析
sidebarDepth: 3
category: python
tags:
-   python
-   fastapi
---
# 序言
> If I have seen further, it is by standing on the shoulders of giants.   —— Isaac Newton

[FastAPI](https://fastapi.tiangolo.com/) 是一个用于构建 API 的高性能 web 框架。该框架基于 Python 3.6+ 的类型注解语法，并完全兼容 API 相关的开放标准：**OpenAPI**（以前被称为 Swagger）和 **JSON Schema**，在此基础上实现了**接口文档自动生成功能**和**依赖注入**。
除此之外，FastAPI 使用 [Pydantic](https://pydantic-docs.helpmanual.io/) 进行自定义数据类型的定义和校验，并且基于依赖注入实现了 Pydantic 对象自动初始化的功能；同时，FastAPi 实际上是 [Starlette](https://www.starlette.io/) 的一个子类，因此提供了所有 Starlette 的特性和性能。

由于 FastAPI 设计精简，文档国际化完善，本文不会介绍 [如何使用 FastAPI](https://fastapi.tiangolo.com/zh/tutorial/)，而是将着重点放在 **如何实现 FastAPI** 之上。

# 如何实现 FastAPI
FastAPI 站在了巨人的肩上，作为 Web 框架所需要的基础设施(Session、Cookie、CORS、ASGI...)完全由底层的 **Starlette** 提供，而对于 **JSON Schema** 的生成又完全依托于 **Pydantic** 来实现，自身则充当了两者的粘合剂，主要实现了两大功能，分别是 **依赖注入** 和 **基于 OpenAPI 的接口文档自动生成** 。接下来则分别针对这两者进行具体介绍。

## 控制反转、依赖注入
### 控制反转
> Don't Call Us, We'll Call You.  —— The Hollywood principle.

控制反转是设计框架中常见的设计模式。实际上，控制反转通常被视为框架的定义特征。顾名思义，控制反转中的**反转**体现在函数调用的**控制权反转**。一般而言，用户定义的函数应该被用户自身的代码所调用，而**控制反转**模式则提倡用户函数应该被开发框架本身调用，框架在整个应用中充当了**主程序**的角色。
例如，在编写 CLI 程序中，如果不使用**控制反转**原则，常见的流程如下:
```python
import argparse


def summation():
    """输入一个整数列表并计算总和"""
    parser = argparse.ArgumentParser(description='Process some integers.')
    parser.add_argument('integers', metavar='N', type=int, nargs='+',
                        help='an integer for the accumulator')
    args = parser.parse_args()
    print(sum(args.integers))


if __name__ == '__main__':
    summation()
```
如果使用**控制反转**, 相关的代码就变成:
```python
import typer  # typer 是基于 type hints 的 CLI 程序框架
from typing import List

def summation(intergers: List[int] = typer.Argument(..., help='an integer for the accumulator')):
    """输入一个整数列表并计算总和"""
    print(sum(intergers))


if __name__ == '__main__':
    typer.run(summation)
```
这两个程序之间的控制流程最大的差异在于，何时执行 *summation*，当使用框架编程时，调用*summation*的控制权被转移至框架手上，只有参数传递正确时，*summation* 才会被框架调用，这种现象就是所谓的**控制反转**。

### 依赖注入与组成根模式
控制反转和依赖注入常被相提并论，实际上两则并非同样的概念。控制反转强调的是**代码控制流程的反转**，而**依赖注入**强调的是**对象初始化的控制权反转**。因此，我们可以认为依赖注入是控制转移的具体实现之一。
依赖注入的核心思想是由框架提供一种与类定义无关的构造依赖图的机制，由框架保证依赖的构造时机和顺序。一般而言，依赖注入分为两大步骤，分别是**对象构造**和**对象注入**。

#### 对象构造
依据**对象构造**的实现方式可以将分成两大类型，分别是 **Constructor Injection(基于构造函数注入)**， **Interface Injection(基于接口注入)**。

##### Constructor Injection
在基于构造函数注入中，类所需的依赖项作为构造函数的参数提供（FastAPI 实现了该类型的依赖注入）。例如，我们可以如下声明一个接口和对应的依赖:
```python
import datetime
from pydantic import BaseModel
from fastapi import FastAPI


class School(BaseModel):
    name: str


class Graduate(BaseModel):
    name: str
    school: School
    graduation_date: datetime.date


app = FastAPI()


@app.post("/graduate/register")
async def graduate_registration(graduate: Graduate):
    return {"message": f"Someone called {graduate.name} graduated from {graduate.school.name} in {graduate.graduation_date.isoformat()}."}
```
在 FastAPI 框架中，使用构造函数来决定如何注入一个依赖，在该案例中则是如何构造一个 Graduate 对象。我们已事先将该接口声明成 POST 方法，依据 OpenAPI 定义的接口规范，FastAPI 只需从 post body 中解析出相应的输入参数，即可自动构造出对应的依赖实例，并注入到业务代码 graduate_registration 之中。
在整个接口调用的过程中，**Graduate** 对象（和 **School** 对象）的构造和函数入参传递均是由 FastAPI 框架完成的，大大简化了业务代码前置的初始化工作（参数校验和类型转换等.), 保证了接口只会出现相应的业务逻辑代码，提高了开发效率，对此 FastAPI 号称能**提高功能开发速度约 200％ 至 300％**。

##### Interface Injection
在基于接口注入中，类所需的依赖项由预先定义的接口进行赋值。与基于构造函数注入最大的不同点在于，基于接口注入的类对象允许为该属性**预设默认值**。
::: tip
在基于接口注入的具体实现中，常见的一类型是基于 **setter** 进行赋值，因而也会细分成 **Setter Injection** 或 **Property Injection**。   
由于具体依赖注入的实现的差异，会有人将类似 **obj.property = value** 这样的属性注入认为是不同于 **Interface Injection** 的另一种实现方式。实际上两则的差异仅在于编程语言的具体实现细节之上，如果认为类属性也是对象，而对属性赋值是隐式调用该属性的 **setter** 方法时，那么在形式上两则是等同的。
:::
在 Java 等静态语言中，这类型的依赖注入最为常见，也由此诞生了一个专有名词：**JavaBean**。所谓 JavaBean，是指遵循以下规范定义的类：
- 提供一个默认的无参构造函数
- 包含若干属于 `private` 级别的实例字段
- 包含若干属于 `public` 的 getter 或 setter 方法
- 可被序列化并实现 Serializable 接口
```java
public class School {
    private String name;
    public String getName() {return this.name;}
    public String setName(String name) {this.name = name;}
}

public class Graduate {
    private String name;
    private School school;
    private Date graduationDate;

    public String getName() {return this.name;}
    public void setName(String name) {this.name = name;}

    public School getSchool() {return this.school;}
    public void setSchool(School school) {this.school = school;}

    public Date getGraduationDate() {return this.graduationDate;}
    public void setGraduationDate(Date graduationDate) {this.graduationDate = graduationDate;}
}
```
在 Spring 框架中，最常见的依赖注入方式则是 **Setter Injection**。Spring 框架支持通过多种方式声明对象配置，常见的方案是使用 XML 文件进行配置，例如:
```xml
<beans>
    <bean id="School" class="School">
        <property name="name">
            <value>some school name</value>
        </property>
    </bean>
    <bean id="Graduate" class="Graduate">
        <property name="name">
            <value>some body name</value>
        </property>
        <property name="school">
            <ref local="School"/>
        </property>
        <property name="graduationDate">
            <value>yyyy-MM-dd</value>
        </property>
    </bean>
</beans>
```

#### 组成根模式
在**对象构造**流程中，每个类都通过构造函数或接口声明了其所需的依赖，但这却将注入具体依赖项的行为委托于第三方实现，那这应该由谁维护这些依赖关系呢？为了解决这个问题，**依赖注入模式**提出了**The Composition Root Pattern(组成根模式)**。组成根模式认为，应当在最接近应用程序入口的地方提供唯一一个组合各模块的切面，也就是说，组成根模式的核心思想在于在程序启动之初即维护一个依赖容器(也可称之为上下文)，**该容器应当具有构建所有依赖项所需的配置**。
在实际实现中，每个类仅负责通过构造函数、接口或其他方式声明所需依赖，当程序启动时实例化依赖容器，借助依赖容器将依赖图“**编译**”成对象图，以 FastAPI 框架为例:
```python
import datetime
from pydantic import BaseModel
from fastapi import Depends, FastAPI
from typing import Optional, List


class LimitOffsetPagination:
    def __init__(self, limit: Optional[int] = 20, offset: Optional[int] = 10):
        self.limit = limit
        self.offset = offset


app = FastAPI()


@app.get("/list_something/")
async def list_something(pagination: LimitOffsetPagination = Depends(LimitOffsetPagination)):
    ...

```
在程序启动时，FastAPI 会依据接口声明的依赖(Depends)构造依赖图。当请求进入时，FastAPI 依据 OpenAPI 定义的接口规范，解析请求参数，构造出相应的依赖容器，并依据依赖图中的依赖关系构造相应的对象，再传递进接口函数，完成整个调用流程。

### 小结
在实际编程中，使用依赖注入可以大大**简化参数校验和类型转换的代码**，使得接口的代码几乎完全是业务的核心逻辑，不仅能**提高开发效率，还能降低代码的维护成本**。同时，对于接口的集成测试，也无需像一般的 Web 框架一样构造 request 对象，只需构造 API 所需的依赖对象，即**可直接进行集成测试**。虽然引入依赖注入的好处明显，但是会**使得调用链路复杂化**。同时引入“**图**”的概念会提高业务模块划分的要求，需避免依赖图中出现“**环**”，否则将使得依赖关系无法解决，因此该类型框架**不适合应用于复杂场景**。


## 基于 OpenAPI 的接口文档自动生成
相对于依赖注入功能，基于 OpenAPI 的接口文档自动生成能力更像是一个附赠品。在生成依赖图的过程中，FastAPI 依据 OpenAPI 相应的规范定义了 **Path**、**Query**、**Cookie**、**Header** 以及 **Body** 的字段描述，用于声明如何从依赖容器中获取到相应的依赖项，而接口文档则可以认为是依赖图的一种可视化形式。

### OpenAPI
[OpenAPI](https://swagger.io/specification/) 定义了语言无关的 RESTful API 设计标准。OpenAPI 的规范主要由 **Path**、**Operation**、**Parameter**、**Request Body**、**Response**、**Schema**组成，其中:
- Path: 描述单个路径上可用的操作，如 get、post、put、delete 等。
- Operation: 描述操作的具体定义，包含 parameters、requestBody、responses 等属性。
- Parameter: 描述请求接口需要传递的参数的名称和位置。
- RequestBody: 描述单个请求的正文内容。
- Response: 描述来自API操作的响应。
- Schema: 描述输入、输出的数据类型，属于 [JSON Schema](https://json-schema.org/) 的扩展子集。

### 文档生成流程
文档生成流程也就是将接口转换成 OpenAPI 相应的对象的流程，具体的文档生成流程描述如下:
首先，FastAPI 所有路由均注册在 Starlette App 之下, 因此可以遍历路由表获取到所有的 Paths 和对应的 Operation。基于 Python 3.6+ 的类型注解语法，FastAPI 可以直接获取到接口的输入、输出参数的数据类型。随后，借助 Pydantic 的能力，FastAPI 可以将 Python 内置的数据类型和复杂的 Pydantic 对象转换成兼容 OpenAPI 规范的 JSON Schema 范式。最后将 OpenAPI 对象组装返回，则可获得对应的接口文档。
TODO: 补个图吧，不知道写啥好

### 小结

# 总结
TODO