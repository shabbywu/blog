---
title: 回顾协程[翻译]
sidebarDepth: 3
tag: cs
---
# Revisiting Coroutines-回顾协程
## Abstract
本文捍卫协程作为通用控制抽象的复兴。在提出新的协程分类以后，我们介绍了完全不对称协程的概念，并通过操作语义对其进行了精确的定义。然后，我们证明了完整的协程具有相当于单发连续和单发局部连续的表达能力。我们还表明，完全不对称的协同程序和一次性部分延续具有许多相似之处，因此具有可比性。 尽管如此，协程与其相比更容易实现和理解，特别是在过程语言领域。最后，我们提供了一组编程示例，说明了使用完全不对称协程来支持几种有用控制行为的直接和简洁实现，其中包括协作式多任务处理。


## Introduction
协程是通用控制抽象的最古老的方案之一，它的概念是在19世纪60年代初由Conway提出的。他将协程描述为“充当主程序的子例程”，并实现了协程以简化COBOL编译器中的词法和句法分析器之间的协作。在接下来的二十年中，协程用于表达控制行为的能力在不同领域中得到了广泛的探索，其中包括了模拟，人工智能，并发编程，文本处理以及各种数据结构操作。尽管如此，除了少数特例以外(如Simula), 其他通用语言的设计者却忽略了为程序员提供这种强大的控制结构的便利之处, BCPL, Modula-2, and Icon。   
主流语言中缺乏对协程的支持，部分的原因可以归结为缺乏对协程这一概念的统一看法，其实协程也从未得到精确定义。Marlin的博士学位论文被广泛认为是该机制的参考，它重新定义了协程应该拥有以下的基本特征：
- “协程中的局部变量在连续调用之间因保持不变”
- “当协程的执行由于控制权转移而被挂起后，在随后的某个阶段重新进入协程时，仅能在被挂起的地方继续执行”
协程的这种描述与对该概念的普遍认知相一致，但是如何实现协程的有关问题尚待解决。除了保持状态的能力以外，我们还可以从以下三个主要问题区分协程：
- 从`控制传递机制`可以区分为对称或不对称协程
- 协程是否为该语言的`第一类对象`(也就是可以由程序员自由操作、还是需要受到约束)
- 协程是否为`堆栈结构`，即协程是否能够从嵌套调用中暂停执行   
根据协程机制的预期用途，上述的问题有不同的解决方案。因此，协程也有完全不同的实现方案，例如Simula语言和Modula语言的协程机制、Icon语言的生成器和共表达式以及最近推出的Python语言的生成器。尽管所有的这些构造都满足 Marlin 对协程的一般描述，但他们却提供了不一样的协程实现。   
除了缺乏精确的定义以外，first-class continuations 的引入也极大促进了协程作为通用控制抽象的研究。与协程不同，first-class continuations有明确的定义，并被认为是一种可用于实现一些有趣功能的表达结构，包括生成器、异常处理、回溯、源码级别的多任务以及协程。但是，除了Scheme、ML的一些实现以及Python的替代实现(备注: Stackless Python），first-class continuations 通常不被编程语言提供。   
在编程语言中加入 continuations 的一个难题是很难有效地实现该构造。此困难主要是由于需要支持多次调用 continuation, 这就意味着在修改捕获的 continuation 前，需要对其进行复制。但是在大多数情况下，continuations 实际上只有被激活时才被调用，因此引入仅限单词调用的 one-shot continuations，从而消除了与 multi-shot continuations 相关的复制开销。在几乎所有的应用场景中，one-shot continuations 可替换 multi-shot continuations。特别是在执行多任务处理时, one-shot continuations 能够比 multi-shot continuations 提供显著的性能优势。   
除了效率问题以外，将 continuation 这一概念用于表示其余的计算(备注: `其余的计算`应该是指continuation的主要使用场景以外的计算）是很难管理和理解的，尤其是在过程语言的情况下。 continuation 调用的中止性质使得程序结构大大复杂化，即使是经验丰富的程序员，也可能难以理解充斥着 continuation 的应用程序的控制流程。通过限制 continuation 的规模和本地化其控制运算符的效果带来的便利性促使了 partial continuations 这一概念的诞生，以及基于此概念的一些了构造的方案。与传统的 continuation 不同，partial continuations 仅代表 continuations 的片段，或者是 continuations 的子计算。partial continuations 不是中止，它们由当前的 continuation 组成，也因此其行为类似于常规函数。Danvy 和 Filinski、Queinnec 和 Serpette 以及 Sitaram 都证明了基于 partial continuations 实现的控制结构可以比基于continuations 实现的控制结构提供更清晰和易理解的经典应用程序(包括生成器、回溯和多任务)。在所有这些应用程序中，施加与 one-shot continuations 同样的限制，可以更有效的实现控制结构。尽管它们具有优于传统 continuations 的优势，但在编程语言的常见实现中深圳在 Scheme 领域中都没有提供 partial continuations 的实现。   
现代语言中缺少协程的另一个重要原因是采用多线程已成为当前并发编程的事实上的标准。在过去的几年中，以及有一些研究工作致力于寻找另外的并发模型，这些模型可以支持更高效、更不易出错的应用程序，例如事件驱动编程和协作式多任务处理。但是，主流语言(如Java和C#)扔将多线程作为其主要的并发结构。   
本文的目的是捍卫协程作为通用控制抽象的复兴，因为它很适合过程语言，并未易于实现和理解。我们议论并证明，与普通的看法相反，协程的表达能力并不低于 continuations。相反，当作为第一类对象并实施时作为堆栈结构（也就是说，当实现完整的协程机制时），协程具有与 one-shot continuations 相同的功能。基于与 partial continuations 机制提案中相似的论点--易于管理和理解，以及对更结构化的应用程序的支持--我们特别的提出完全不对称协程作为语言可扩展性的适当结构。   
本文的其余部分安排如下：第2节根据前面提到的三个问题提出了协程机制的分类，并讨论了它们对协程设施有效性的影响；第3节正式描述了我们的完整非对称协程概念，并以实现该机制的通用编程语言为例进行了说明。在第4节中，我们显示了完全不对称的协程不仅可以提供对称的协程设施，而且还可以提供 one-shot continuations和one-shot partial continuations。第5节包含使用完整不对称协程直接实现一些有用的控制行为（包括多任务）的编程示例集合。最后，第6节总结了论文并提出了我们的结论。

##  协程分类